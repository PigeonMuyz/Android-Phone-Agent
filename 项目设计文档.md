# Android Phone Agent è®¾è®¡æ–‡æ¡£

> ä¸€ä¸ªæ”¯æŒå¤š VLM æä¾›å•†ã€å¤š App ä¸“å± Prompt å’Œæ¨¡å‹è®¡è´¹çš„æ‰‹æœºè‡ªåŠ¨åŒ–æ™ºèƒ½ä½“æ¡†æ¶ã€‚çµæ„Ÿæ¥è‡ªï¼š[Open-AutoGLM](https://github.com/zai-org/Open-AutoGLM)

---

## ğŸ“‹ ç›®å½•

1. [ç³»ç»Ÿæ¦‚è§ˆ](#ç³»ç»Ÿæ¦‚è§ˆ)
2. [æ ¸å¿ƒæ¶æ„](#æ ¸å¿ƒæ¶æ„)
3. [æ¨¡å—è¯¦ç»†è®¾è®¡](#æ¨¡å—è¯¦ç»†è®¾è®¡)
4. [å¤šæ¨¡å‹é€‚é…å±‚](#å¤šæ¨¡å‹é€‚é…å±‚)
5. [æ¨¡å‹è®¡è´¹ç³»ç»Ÿ](#æ¨¡å‹è®¡è´¹ç³»ç»Ÿ)
6. [å¤šè®¾å¤‡ç®¡ç†](#å¤šè®¾å¤‡ç®¡ç†) â­ æ–°å¢
7. [App ä¸“å± Prompt ç³»ç»Ÿ](#app-ä¸“å±-prompt-ç³»ç»Ÿ)
8. [é¡¹ç›®ç»“æ„](#é¡¹ç›®ç»“æ„)
9. [é…ç½®ç³»ç»Ÿ](#é…ç½®ç³»ç»Ÿ)
10. [æ‰©å±•æŒ‡å—](#æ‰©å±•æŒ‡å—)

---

## ç³»ç»Ÿæ¦‚è§ˆ

### æ ¸å¿ƒå·¥ä½œæµç¨‹

```mermaid
flowchart TB
    subgraph ä¸»å¾ªç¯["ğŸ”„ Agent Loop"]
        A[ğŸ“¸ ADB æˆªå›¾] --> B[ğŸ§  VLM åˆ†æ]
        B --> C[ğŸ“‹ è§£æåŠ¨ä½œ]
        C --> D[ğŸ“± æ‰§è¡Œæ“ä½œ]
        D --> E[ğŸ’° è®¡è´¹ç»Ÿè®¡]
        E --> A
    end
    
    User[ğŸ‘¤ ç”¨æˆ·ä»»åŠ¡] --> ä¸»å¾ªç¯
    Config[âš™ï¸ é…ç½®] --> ä¸»å¾ªç¯
    ä¸»å¾ªç¯ --> Result[âœ… ä»»åŠ¡å®Œæˆ]
    
    subgraph å¤šæ¨¡å‹å±‚["ğŸ”Œ Multi-Provider Layer"]
        OpenAI[OpenAI API]
        Gemini[Google Gemini]
        Anthropic[Anthropic Claude]
        Volcano[ç«å±±æ–¹èˆŸ]
    end
    
    B <--> å¤šæ¨¡å‹å±‚
    
    subgraph è®¡è´¹å±‚["ğŸ’° Billing Layer"]
        PricingConfig[ä»·æ ¼é…ç½®]
        UsageTracker[ç”¨é‡è¿½è¸ª]
        CostCalculator[æˆæœ¬è®¡ç®—]
    end
    
    E --> è®¡è´¹å±‚
```

### è®¾è®¡åŸåˆ™

| åŸåˆ™ | è¯´æ˜ |
|------|------|
| **æä¾›å•†æ— å…³** | ç»Ÿä¸€æŠ½è±¡å±‚ï¼Œè½»æ¾åˆ‡æ¢ VLM æä¾›å•† |
| **æ’ä»¶åŒ– Prompt** | App ä¸“å± Prompt å¯çƒ­æ’æ‹”ï¼Œæ”¯æŒ YAML/Python é…ç½® |
| **ç±»å‹å®‰å…¨** | ä½¿ç”¨ Pydantic æ¨¡å‹è¿›è¡Œè¯·æ±‚/å“åº”éªŒè¯ |
| **æˆæœ¬é€æ˜** | å®æ—¶è®¡è´¹ç»Ÿè®¡ï¼Œæ”¯æŒå¤šç§è®¡è´¹æ¨¡å¼ |
| **å¼‚æ­¥ä¼˜å…ˆ** | æ”¯æŒå¼‚æ­¥ API è°ƒç”¨ï¼Œæé«˜å¹¶å‘æ€§èƒ½ |

---

## æ ¸å¿ƒæ¶æ„

### åˆ†å±‚æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      ğŸ¯ Application Layer                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   CLI App   â”‚  â”‚   Web API   â”‚  â”‚   Python SDK        â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                      ğŸ¤– Agent Core Layer                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚  PhoneAgent: ä»»åŠ¡è°ƒåº¦ / çŠ¶æ€ç®¡ç† / æ­¥éª¤æ‰§è¡Œ              â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   ğŸ§  Model Abstraction Layer                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚                    VLMClient (Abstract)                  â”‚â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚â”‚
â”‚  â”‚  â”‚ OpenAI   â”‚ â”‚ Gemini   â”‚ â”‚Claude    â”‚ â”‚ ç«å±±æ–¹èˆŸ     â”‚â”‚â”‚
â”‚  â”‚  â”‚ Client   â”‚ â”‚ Client   â”‚ â”‚Client    â”‚ â”‚ Client       â”‚â”‚â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    ğŸ’° Billing Layer (NEW)                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚  BillingManager: ä»·æ ¼é…ç½® / ç”¨é‡è¿½è¸ª / æˆæœ¬æŠ¥å‘Š          â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    ğŸ“ Prompt Management Layer                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚  PromptManager: ç³»ç»Ÿ Prompt / App ä¸“å± Prompt / åŠ¨æ€æ³¨å…¥ â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    ğŸ“± Device Control Layer                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚  ADBController: æˆªå›¾ / ç‚¹å‡» / æ»‘åŠ¨ / è¾“å…¥ / åº”ç”¨ç®¡ç†     â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## æ¨¡å—è¯¦ç»†è®¾è®¡

### 1. Agent Core (`agent/`)

```python
# agent/core.py
from pydantic import BaseModel
from typing import Any

class AgentConfig(BaseModel):
    """Agent é…ç½®"""
    max_steps: int = 100
    device_id: str | None = None
    language: str = "zh"
    verbose: bool = True
    # æ¨¡å‹æä¾›å•†é…ç½®
    provider: str = "openai"  # openai | gemini | anthropic | volcano
    model_config: dict[str, Any] = {}
    # è®¡è´¹é…ç½®
    enable_billing: bool = True  # æ˜¯å¦å¯ç”¨è®¡è´¹

class StepResult(BaseModel):
    """å•æ­¥æ‰§è¡Œç»“æœ"""
    success: bool
    finished: bool
    action: dict[str, Any] | None
    thinking: str
    message: str | None = None
    # è®¡è´¹ä¿¡æ¯
    step_cost: float = 0.0
    prompt_tokens: int = 0
    completion_tokens: int = 0

class PhoneAgent:
    """æ‰‹æœºè‡ªåŠ¨åŒ–æ™ºèƒ½ä½“æ ¸å¿ƒ"""
    
    def __init__(
        self,
        config: AgentConfig,
        vlm_client: "BaseVLMClient",
        prompt_manager: "PromptManager",
        action_handler: "ActionHandler",
        billing_manager: "BillingManager | None" = None,
    ):
        self.config = config
        self.vlm_client = vlm_client
        self.prompt_manager = prompt_manager
        self.action_handler = action_handler
        self.billing_manager = billing_manager
        self._context: list[dict] = []
        self._step_count = 0
        self._total_cost = 0.0
    
    def run(self, task: str) -> str:
        """æ‰§è¡Œä»»åŠ¡"""
        self.reset()
        
        system_prompt = self.prompt_manager.get_system_prompt(self.config.language)
        self._context.append({"role": "system", "content": system_prompt})
        
        while self._step_count < self.config.max_steps:
            result = self._execute_step(task if self._step_count == 0 else None)
            
            # ç´¯è®¡æˆæœ¬
            self._total_cost += result.step_cost
            
            if result.finished:
                self._print_billing_summary()
                return result.message or "ä»»åŠ¡å®Œæˆ"
        
        self._print_billing_summary()
        return "è¾¾åˆ°æœ€å¤§æ­¥æ•°é™åˆ¶"
    
    def _print_billing_summary(self) -> None:
        """æ‰“å°è®¡è´¹æ‘˜è¦"""
        if self.billing_manager and self.config.enable_billing:
            summary = self.billing_manager.get_task_summary()
            print(f"\n{'='*50}")
            print(f"ğŸ’° ä»»åŠ¡æˆæœ¬ç»Ÿè®¡:")
            print(f"   æä¾›å•†: {summary.provider}")
            print(f"   æ¨¡å‹: {summary.model}")
            print(f"   è¾“å…¥ Tokens: {summary.total_prompt_tokens:,}")
            print(f"   è¾“å‡º Tokens: {summary.total_completion_tokens:,}")
            print(f"   æ€»æˆæœ¬: ${summary.total_cost:.6f} (â‰ˆ Â¥{summary.total_cost * 7.2:.4f})")
            print(f"{'='*50}\n")
```

### 2. Action Handler (`agent/actions.py`)

```python
# agent/actions.py
from dataclasses import dataclass
from enum import Enum
from typing import Callable

class ActionType(str, Enum):
    TAP = "Tap"
    SWIPE = "Swipe"
    TYPE = "Type"
    LAUNCH = "Launch"
    BACK = "Back"
    HOME = "Home"
    WAIT = "Wait"
    LONG_PRESS = "Long Press"
    DOUBLE_TAP = "Double Tap"
    FINISH = "finish"
    PAUSE = "pause"

@dataclass
class ActionResult:
    success: bool
    should_finish: bool
    message: str | None = None

class ActionHandler:
    """åŠ¨ä½œå¤„ç†å™¨"""
    
    def __init__(self, adb: "ADBController"):
        self.adb = adb
        self._handlers: dict[ActionType, Callable] = {
            ActionType.TAP: self._handle_tap,
            ActionType.SWIPE: self._handle_swipe,
            ActionType.TYPE: self._handle_type,
            ActionType.LAUNCH: self._handle_launch,
            # ... å…¶ä»–å¤„ç†å™¨
        }
    
    def execute(self, action: dict, screen_width: int, screen_height: int) -> ActionResult:
        """æ‰§è¡ŒåŠ¨ä½œ"""
        action_type = ActionType(action.get("action", action.get("_metadata")))
        handler = self._handlers.get(action_type)
        if handler:
            return handler(action, screen_width, screen_height)
        return ActionResult(False, False, f"æœªçŸ¥åŠ¨ä½œ: {action_type}")
    
    def _convert_coords(self, element: list[int], width: int, height: int) -> tuple[int, int]:
        """ç›¸å¯¹åæ ‡(0-1000)è½¬ç»å¯¹åƒç´ """
        return int(element[0] / 1000 * width), int(element[1] / 1000 * height)
```

---

## å¤šæ¨¡å‹é€‚é…å±‚

### æŠ½è±¡åŸºç±»è®¾è®¡

```python
# providers/base.py
from abc import ABC, abstractmethod
from pydantic import BaseModel
from typing import Any

class VLMResponse(BaseModel):
    """ç»Ÿä¸€å“åº”æ ¼å¼"""
    thinking: str
    action: str
    raw_content: str
    # Token ç»Ÿè®¡ (ç”¨äºè®¡è´¹)
    prompt_tokens: int = 0
    completion_tokens: int = 0
    total_tokens: int = 0

class BaseVLMClient(ABC):
    """VLM å®¢æˆ·ç«¯æŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    def request(self, messages: list[dict[str, Any]]) -> VLMResponse:
        """å‘é€è¯·æ±‚å¹¶è·å–å“åº”"""
        pass
    
    @abstractmethod
    def parse_response(self, raw_content: str) -> tuple[str, str]:
        """è§£æå“åº”ä¸º (thinking, action)"""
        pass
    
    @property
    @abstractmethod
    def provider_name(self) -> str:
        """æä¾›å•†åç§°"""
        pass
    
    @property
    @abstractmethod
    def model_name(self) -> str:
        """æ¨¡å‹åç§° (ç”¨äºè®¡è´¹æŸ¥æ‰¾)"""
        pass
```

### Provider å·¥å‚

```python
# providers/__init__.py
from typing import Literal
from .base import BaseVLMClient
from .openai_compatible import OpenAIClient, OpenAIConfig
from .gemini import GeminiClient, GeminiConfig
from .anthropic import AnthropicClient, AnthropicConfig
from .volcano import VolcanoClient, VolcanoConfig

ProviderType = Literal["openai", "gemini", "anthropic", "volcano"]

def create_vlm_client(provider: ProviderType, config: dict) -> BaseVLMClient:
    """å·¥å‚æ–¹æ³•ï¼šåˆ›å»º VLM å®¢æˆ·ç«¯"""
    providers = {
        "openai": (OpenAIClient, OpenAIConfig),
        "gemini": (GeminiClient, GeminiConfig),
        "anthropic": (AnthropicClient, AnthropicConfig),
        "volcano": (VolcanoClient, VolcanoConfig),
    }
    
    client_cls, config_cls = providers[provider]
    return client_cls(config_cls(**config))
```

---

## æ¨¡å‹è®¡è´¹ç³»ç»Ÿ

### è®¾è®¡ç›®æ ‡

- âœ… æ”¯æŒ **å›ºå®šä»·æ ¼** ($/ç™¾ä¸‡tokens)
- âœ… æ”¯æŒ **åŒºé—´è®¡è´¹** (æŒ‰ç”¨é‡é˜¶æ¢¯å®šä»·)
- âœ… æ”¯æŒ **å…è´¹é¢åº¦** é…ç½®
- âœ… **å®æ—¶æˆæœ¬è¿½è¸ª** å’ŒæŠ¥å‘Š
- âœ… æ”¯æŒ **YAML é…ç½®** å’Œ **ä»£ç æ³¨å†Œ**

### è®¡è´¹æ¨¡å‹å®šä¹‰

```python
# billing/models.py
from pydantic import BaseModel, Field
from typing import Literal
from enum import Enum

class PricingType(str, Enum):
    """è®¡è´¹ç±»å‹"""
    FIXED = "fixed"           # å›ºå®šä»·æ ¼
    TIERED = "tiered"         # é˜¶æ¢¯è®¡è´¹
    FREE = "free"             # å®Œå…¨å…è´¹

class PriceTier(BaseModel):
    """ä»·æ ¼é˜¶æ¢¯ï¼ˆç”¨äºåŒºé—´è®¡è´¹ï¼‰"""
    min_tokens: int = 0                    # èµ·å§‹ token æ•°
    max_tokens: int | None = None          # ç»“æŸ token æ•° (None = æ— ä¸Šé™)
    input_price: float                     # è¯¥åŒºé—´è¾“å…¥ä»·æ ¼ ($/ç™¾ä¸‡tokens)
    output_price: float                    # è¯¥åŒºé—´è¾“å‡ºä»·æ ¼ ($/ç™¾ä¸‡tokens)

class ModelPricing(BaseModel):
    """æ¨¡å‹è®¡è´¹é…ç½®"""
    provider: str                          # æä¾›å•†åç§°
    model: str                             # æ¨¡å‹åç§°/ID
    display_name: str | None = None        # æ˜¾ç¤ºåç§°
    pricing_type: PricingType = PricingType.FIXED
    
    # å›ºå®šä»·æ ¼æ¨¡å¼
    input_price_per_million: float = 0.0   # è¾“å…¥ä»·æ ¼ ($/ç™¾ä¸‡tokens)
    output_price_per_million: float = 0.0  # è¾“å‡ºä»·æ ¼ ($/ç™¾ä¸‡tokens)
    
    # é˜¶æ¢¯è®¡è´¹æ¨¡å¼
    tiers: list[PriceTier] = Field(default_factory=list)
    
    # å…è´¹é¢åº¦
    free_input_tokens: int = 0             # æ¯æœˆå…è´¹è¾“å…¥ tokens
    free_output_tokens: int = 0            # æ¯æœˆå…è´¹è¾“å‡º tokens
    
    # å…ƒæ•°æ®
    currency: str = "USD"                  # è´§å¸å•ä½
    last_updated: str | None = None        # ä»·æ ¼æ›´æ–°æ—¥æœŸ
    notes: str | None = None               # å¤‡æ³¨

class UsageRecord(BaseModel):
    """å•æ¬¡è°ƒç”¨è®°å½•"""
    timestamp: str
    provider: str
    model: str
    prompt_tokens: int
    completion_tokens: int
    input_cost: float
    output_cost: float
    total_cost: float

class TaskBillingSummary(BaseModel):
    """ä»»åŠ¡è®¡è´¹æ‘˜è¦"""
    provider: str
    model: str
    total_prompt_tokens: int
    total_completion_tokens: int
    total_input_cost: float
    total_output_cost: float
    total_cost: float
    step_count: int
    records: list[UsageRecord] = Field(default_factory=list)
```

### è®¡è´¹ç®¡ç†å™¨å®ç°

```python
# billing/manager.py
from datetime import datetime
from typing import Any
from .models import ModelPricing, PricingType, UsageRecord, TaskBillingSummary

class BillingManager:
    """è®¡è´¹ç®¡ç†å™¨"""
    
    def __init__(self):
        self._pricing_registry: dict[str, ModelPricing] = {}
        self._usage_records: list[UsageRecord] = []
        self._total_prompt_tokens = 0
        self._total_completion_tokens = 0
        self._total_cost = 0.0
    
    def register_pricing(self, pricing: ModelPricing) -> None:
        """æ³¨å†Œæ¨¡å‹ä»·æ ¼"""
        key = f"{pricing.provider}:{pricing.model}"
        self._pricing_registry[key] = pricing
    
    def register_pricing_from_dict(self, config: dict) -> None:
        """ä»å­—å…¸æ³¨å†Œæ¨¡å‹ä»·æ ¼"""
        pricing = ModelPricing(**config)
        self.register_pricing(pricing)
    
    def get_pricing(self, provider: str, model: str) -> ModelPricing | None:
        """è·å–æ¨¡å‹ä»·æ ¼é…ç½®"""
        key = f"{provider}:{model}"
        return self._pricing_registry.get(key)
    
    def calculate_cost(
        self, 
        provider: str, 
        model: str, 
        prompt_tokens: int, 
        completion_tokens: int
    ) -> tuple[float, float, float]:
        """
        è®¡ç®—è°ƒç”¨æˆæœ¬
        
        Returns:
            (input_cost, output_cost, total_cost)
        """
        pricing = self.get_pricing(provider, model)
        
        if pricing is None:
            # æœªæ³¨å†Œçš„æ¨¡å‹ï¼Œè¿”å› 0 æˆæœ¬ä½†è®°å½•è­¦å‘Š
            print(f"âš ï¸ æœªæ‰¾åˆ°æ¨¡å‹å®šä»·é…ç½®: {provider}:{model}")
            return 0.0, 0.0, 0.0
        
        if pricing.pricing_type == PricingType.FREE:
            return 0.0, 0.0, 0.0
        
        if pricing.pricing_type == PricingType.FIXED:
            return self._calculate_fixed_cost(pricing, prompt_tokens, completion_tokens)
        
        if pricing.pricing_type == PricingType.TIERED:
            return self._calculate_tiered_cost(pricing, prompt_tokens, completion_tokens)
        
        return 0.0, 0.0, 0.0
    
    def _calculate_fixed_cost(
        self, 
        pricing: ModelPricing, 
        prompt_tokens: int, 
        completion_tokens: int
    ) -> tuple[float, float, float]:
        """è®¡ç®—å›ºå®šä»·æ ¼æˆæœ¬"""
        # æ‰£é™¤å…è´¹é¢åº¦
        billable_prompt = max(0, prompt_tokens - pricing.free_input_tokens)
        billable_completion = max(0, completion_tokens - pricing.free_output_tokens)
        
        input_cost = (billable_prompt / 1_000_000) * pricing.input_price_per_million
        output_cost = (billable_completion / 1_000_000) * pricing.output_price_per_million
        
        return input_cost, output_cost, input_cost + output_cost
    
    def _calculate_tiered_cost(
        self, 
        pricing: ModelPricing, 
        prompt_tokens: int, 
        completion_tokens: int
    ) -> tuple[float, float, float]:
        """è®¡ç®—é˜¶æ¢¯ä»·æ ¼æˆæœ¬"""
        input_cost = 0.0
        output_cost = 0.0
        
        remaining_prompt = prompt_tokens
        remaining_completion = completion_tokens
        
        for tier in sorted(pricing.tiers, key=lambda t: t.min_tokens):
            if remaining_prompt <= 0 and remaining_completion <= 0:
                break
            
            tier_max = tier.max_tokens if tier.max_tokens else float('inf')
            tier_size = tier_max - tier.min_tokens
            
            # è®¡ç®—è¯¥é˜¶æ¢¯çš„è¾“å…¥ tokens
            prompt_in_tier = min(remaining_prompt, tier_size)
            if prompt_in_tier > 0:
                input_cost += (prompt_in_tier / 1_000_000) * tier.input_price
                remaining_prompt -= prompt_in_tier
            
            # è®¡ç®—è¯¥é˜¶æ¢¯çš„è¾“å‡º tokens
            completion_in_tier = min(remaining_completion, tier_size)
            if completion_in_tier > 0:
                output_cost += (completion_in_tier / 1_000_000) * tier.output_price
                remaining_completion -= completion_in_tier
        
        return input_cost, output_cost, input_cost + output_cost
    
    def record_usage(
        self, 
        provider: str, 
        model: str, 
        prompt_tokens: int, 
        completion_tokens: int
    ) -> UsageRecord:
        """è®°å½•ä¸€æ¬¡è°ƒç”¨å¹¶è®¡ç®—æˆæœ¬"""
        input_cost, output_cost, total_cost = self.calculate_cost(
            provider, model, prompt_tokens, completion_tokens
        )
        
        record = UsageRecord(
            timestamp=datetime.now().isoformat(),
            provider=provider,
            model=model,
            prompt_tokens=prompt_tokens,
            completion_tokens=completion_tokens,
            input_cost=input_cost,
            output_cost=output_cost,
            total_cost=total_cost,
        )
        
        self._usage_records.append(record)
        self._total_prompt_tokens += prompt_tokens
        self._total_completion_tokens += completion_tokens
        self._total_cost += total_cost
        
        return record
    
    def get_task_summary(self) -> TaskBillingSummary:
        """è·å–å½“å‰ä»»åŠ¡çš„è®¡è´¹æ‘˜è¦"""
        if not self._usage_records:
            return TaskBillingSummary(
                provider="N/A",
                model="N/A",
                total_prompt_tokens=0,
                total_completion_tokens=0,
                total_input_cost=0.0,
                total_output_cost=0.0,
                total_cost=0.0,
                step_count=0,
            )
        
        last_record = self._usage_records[-1]
        total_input = sum(r.input_cost for r in self._usage_records)
        total_output = sum(r.output_cost for r in self._usage_records)
        
        return TaskBillingSummary(
            provider=last_record.provider,
            model=last_record.model,
            total_prompt_tokens=self._total_prompt_tokens,
            total_completion_tokens=self._total_completion_tokens,
            total_input_cost=total_input,
            total_output_cost=total_output,
            total_cost=self._total_cost,
            step_count=len(self._usage_records),
            records=self._usage_records,
        )
    
    def reset(self) -> None:
        """é‡ç½®è®¡è´¹ç»Ÿè®¡ï¼ˆæ–°ä»»åŠ¡æ—¶è°ƒç”¨ï¼‰"""
        self._usage_records.clear()
        self._total_prompt_tokens = 0
        self._total_completion_tokens = 0
        self._total_cost = 0.0
    
    def export_report(self, format: str = "json") -> str:
        """å¯¼å‡ºè®¡è´¹æŠ¥å‘Š"""
        summary = self.get_task_summary()
        if format == "json":
            return summary.model_dump_json(indent=2)
        # å¯æ‰©å±•å…¶ä»–æ ¼å¼
        return str(summary)
```

### YAML ä»·æ ¼é…ç½®æ ¼å¼

```yaml
# config/pricing.yaml
providers:
  # ============================================
  # OpenAI æ¨¡å‹å®šä»·
  # ============================================
  - provider: openai
    model: gpt-4o
    display_name: GPT-4o
    pricing_type: fixed
    input_price_per_million: 2.50      # $2.50 / 1M tokens
    output_price_per_million: 10.00    # $10.00 / 1M tokens
    last_updated: "2024-12-01"
  
  - provider: openai
    model: gpt-4o-mini
    display_name: GPT-4o Mini
    pricing_type: fixed
    input_price_per_million: 0.15
    output_price_per_million: 0.60
    last_updated: "2024-12-01"
  
  - provider: openai
    model: gpt-4-turbo
    display_name: GPT-4 Turbo
    pricing_type: fixed
    input_price_per_million: 10.00
    output_price_per_million: 30.00
  
  # ============================================
  # Google Gemini æ¨¡å‹å®šä»·
  # ============================================
  - provider: gemini
    model: gemini-2.0-flash
    display_name: Gemini 2.0 Flash
    pricing_type: tiered
    tiers:
      - min_tokens: 0
        max_tokens: 128000
        input_price: 0.075         # $0.075 / 1M (â‰¤128K context)
        output_price: 0.30
      - min_tokens: 128000
        max_tokens: null           # æ— ä¸Šé™
        input_price: 0.15          # $0.15 / 1M (>128K context)
        output_price: 0.60
    last_updated: "2024-12-01"
  
  - provider: gemini
    model: gemini-1.5-pro
    display_name: Gemini 1.5 Pro
    pricing_type: tiered
    tiers:
      - min_tokens: 0
        max_tokens: 128000
        input_price: 1.25
        output_price: 5.00
      - min_tokens: 128000
        max_tokens: null
        input_price: 2.50
        output_price: 10.00
    last_updated: "2024-12-01"
  
  - provider: gemini
    model: gemini-2.0-flash-lite
    display_name: Gemini 2.0 Flash Lite
    pricing_type: free
    notes: "å®Œå…¨å…è´¹ï¼Œæœ‰é€Ÿç‡é™åˆ¶"
  
  # ============================================
  # Anthropic Claude æ¨¡å‹å®šä»·
  # ============================================
  - provider: anthropic
    model: claude-sonnet-4-20250514
    display_name: Claude Sonnet 4
    pricing_type: fixed
    input_price_per_million: 3.00
    output_price_per_million: 15.00
    last_updated: "2024-12-01"
  
  - provider: anthropic
    model: claude-3-5-sonnet-20241022
    display_name: Claude 3.5 Sonnet
    pricing_type: fixed
    input_price_per_million: 3.00
    output_price_per_million: 15.00
  
  - provider: anthropic
    model: claude-3-5-haiku-20241022
    display_name: Claude 3.5 Haiku
    pricing_type: fixed
    input_price_per_million: 0.80
    output_price_per_million: 4.00
  
  - provider: anthropic
    model: claude-3-opus-20240229
    display_name: Claude 3 Opus
    pricing_type: fixed
    input_price_per_million: 15.00
    output_price_per_million: 75.00
  
  # ============================================
  # ç«å±±æ–¹èˆŸï¼ˆè±†åŒ…ï¼‰æ¨¡å‹å®šä»· (äººæ°‘å¸)
  # ============================================
  - provider: volcano
    model: doubao-1-5-thinking-pro-250415
    display_name: è±†åŒ… 1.5 Thinking Pro
    pricing_type: fixed
    input_price_per_million: 0.56    # Â¥4 / 1M tokens â‰ˆ $0.56
    output_price_per_million: 2.22   # Â¥16 / 1M tokens â‰ˆ $2.22
    currency: CNY
    notes: "ä»·æ ¼å·²è½¬æ¢ä¸ºç¾å…ƒï¼ŒåŸä»·: è¾“å…¥Â¥4/ç™¾ä¸‡, è¾“å‡ºÂ¥16/ç™¾ä¸‡"
  
  - provider: volcano
    model: doubao-1-5-pro-256k
    display_name: è±†åŒ… 1.5 Pro 256K
    pricing_type: fixed
    input_price_per_million: 0.11    # Â¥0.8 / 1M â‰ˆ $0.11
    output_price_per_million: 0.28   # Â¥2 / 1M â‰ˆ $0.28
    currency: CNY
  
  - provider: volcano
    model: doubao-vision-pro-32k
    display_name: è±†åŒ…è§†è§‰ Pro 32K
    pricing_type: fixed
    input_price_per_million: 0.42    # Â¥3 / 1M â‰ˆ $0.42
    output_price_per_million: 1.25   # Â¥9 / 1M â‰ˆ $1.25
    currency: CNY
    notes: "è§†è§‰æ¨¡å‹ï¼Œæ”¯æŒå›¾åƒè¾“å…¥"
  
  # ============================================
  # è‡ªéƒ¨ç½²/æœ¬åœ°æ¨¡å‹
  # ============================================
  - provider: local
    model: autoglm-phone-9b
    display_name: AutoGLM Phone 9B (æœ¬åœ°)
    pricing_type: free
    notes: "æœ¬åœ°éƒ¨ç½²ï¼Œæ—  API æˆæœ¬"
  
  - provider: vllm
    model: custom-model
    display_name: è‡ªå®šä¹‰ vLLM æ¨¡å‹
    pricing_type: free
    notes: "æŒ‰ GPU ç®—åŠ›æˆæœ¬å¦è®¡"
```

### ä»·æ ¼é…ç½®åŠ è½½å™¨

```python
# billing/loader.py
import yaml
from pathlib import Path
from .models import ModelPricing, PriceTier, PricingType
from .manager import BillingManager

def load_pricing_config(config_path: str | Path) -> BillingManager:
    """ä» YAML æ–‡ä»¶åŠ è½½ä»·æ ¼é…ç½®"""
    manager = BillingManager()
    
    config_path = Path(config_path)
    if not config_path.exists():
        print(f"âš ï¸ ä»·æ ¼é…ç½®æ–‡ä»¶ä¸å­˜åœ¨: {config_path}")
        return manager
    
    with open(config_path, 'r', encoding='utf-8') as f:
        config = yaml.safe_load(f)
    
    for provider_config in config.get('providers', []):
        # å¤„ç†é˜¶æ¢¯å®šä»·
        if 'tiers' in provider_config:
            provider_config['tiers'] = [
                PriceTier(**tier) for tier in provider_config['tiers']
            ]
        
        pricing = ModelPricing(**provider_config)
        manager.register_pricing(pricing)
        print(f"âœ… å·²åŠ è½½å®šä»·: {pricing.provider}:{pricing.model}")
    
    return manager


def create_default_pricing_manager() -> BillingManager:
    """åˆ›å»ºé»˜è®¤çš„è®¡è´¹ç®¡ç†å™¨ï¼ˆä½¿ç”¨å†…ç½®ä»·æ ¼ï¼‰"""
    manager = BillingManager()
    
    # å†…ç½®é»˜è®¤ä»·æ ¼ï¼ˆå¯è¢« YAML è¦†ç›–ï¼‰
    default_pricing = [
        ModelPricing(
            provider="openai",
            model="gpt-4o",
            pricing_type=PricingType.FIXED,
            input_price_per_million=2.50,
            output_price_per_million=10.00,
        ),
        ModelPricing(
            provider="openai",
            model="gpt-4o-mini",
            pricing_type=PricingType.FIXED,
            input_price_per_million=0.15,
            output_price_per_million=0.60,
        ),
        ModelPricing(
            provider="gemini",
            model="gemini-2.0-flash",
            pricing_type=PricingType.FIXED,
            input_price_per_million=0.075,
            output_price_per_million=0.30,
        ),
        ModelPricing(
            provider="anthropic",
            model="claude-sonnet-4-20250514",
            pricing_type=PricingType.FIXED,
            input_price_per_million=3.00,
            output_price_per_million=15.00,
        ),
    ]
    
    for pricing in default_pricing:
        manager.register_pricing(pricing)
    
    return manager
```

### è®¡è´¹é›†æˆç¤ºä¾‹

```python
# ä½¿ç”¨ç¤ºä¾‹
from phone_agent import PhoneAgent, AgentConfig
from phone_agent.providers import create_vlm_client
from phone_agent.billing import load_pricing_config

# åŠ è½½ä»·æ ¼é…ç½®
billing_manager = load_pricing_config("config/pricing.yaml")

# åˆ›å»º Agent
agent = PhoneAgent(
    config=AgentConfig(
        provider="openai",
        enable_billing=True,
    ),
    vlm_client=create_vlm_client("openai", {
        "api_key": "sk-xxx",
        "model": "gpt-4o-mini",
    }),
    billing_manager=billing_manager,
)

# æ‰§è¡Œä»»åŠ¡
result = agent.run("æ‰“å¼€å¾®ä¿¡å‘æ¶ˆæ¯ç»™å¼ ä¸‰è¯´ä½ å¥½")

# è·å–è¯¦ç»†è®¡è´¹æŠ¥å‘Š
report = billing_manager.export_report()
print(report)
```

**è¾“å‡ºç¤ºä¾‹ï¼š**
```
==================================================
ğŸ’° ä»»åŠ¡æˆæœ¬ç»Ÿè®¡:
   æä¾›å•†: openai
   æ¨¡å‹: gpt-4o-mini
   è¾“å…¥ Tokens: 15,234
   è¾“å‡º Tokens: 1,208
   æ€»æˆæœ¬: $0.003010 (â‰ˆ Â¥0.0217)
==================================================

{
  "provider": "openai",
  "model": "gpt-4o-mini",
  "total_prompt_tokens": 15234,
  "total_completion_tokens": 1208,
  "total_input_cost": 0.002285,
  "total_output_cost": 0.000725,
  "total_cost": 0.003010,
  "step_count": 5,
  "records": [...]
}
```

---

## å¤šè®¾å¤‡ç®¡ç†

æ”¯æŒåŒæ—¶è¿æ¥å¤šä¸ª Android è®¾å¤‡ï¼Œå¹¶è¡Œæ‰§è¡Œä¸åŒä»»åŠ¡ï¼ˆç±»ä¼¼ Google Jules çš„å¤šä»»åŠ¡è®¾è®¡ï¼‰ã€‚

### æ¶æ„è®¾è®¡

```mermaid
flowchart TB
    subgraph TUI["ğŸ–¥ï¸ TUI ç•Œé¢"]
        DeviceList[è®¾å¤‡åˆ—è¡¨é¢æ¿]
        TaskPanel[ä»»åŠ¡ç®¡ç†é¢æ¿]
        LogPanel[æ—¥å¿—é¢æ¿]
    end
    
    subgraph DeviceManager["ğŸ“± DeviceManager"]
        Scanner[è®¾å¤‡æ‰«æå™¨]
        DevicePool[è®¾å¤‡æ± ]
    end
    
    subgraph TaskScheduler["âš™ï¸ TaskScheduler"]
        Queue[ä»»åŠ¡é˜Ÿåˆ—]
        Dispatcher[ä»»åŠ¡åˆ†å‘å™¨]
    end
    
    subgraph Agents["ğŸ¤– Agent Pool"]
        Agent1[Agent #1<br/>Device: Pixel 7]
        Agent2[Agent #2<br/>Device: Samsung S24]
        Agent3[Agent #3<br/>Device: æ¨¡æ‹Ÿå™¨]
    end
    
    DeviceList --> DeviceManager
    TaskPanel --> TaskScheduler
    DeviceManager --> TaskScheduler
    TaskScheduler --> Agents
    Agents --> LogPanel
```

### è®¾å¤‡ç®¡ç†å™¨

```python
# adb/device_manager.py
from pydantic import BaseModel
from enum import Enum
import asyncio

class DeviceState(str, Enum):
    ONLINE = "online"       # åœ¨çº¿ï¼Œå¯ç”¨
    OFFLINE = "offline"     # ç¦»çº¿
    BUSY = "busy"           # æ­£åœ¨æ‰§è¡Œä»»åŠ¡
    UNAUTHORIZED = "unauthorized"  # æœªæˆæƒ

class DeviceInfo(BaseModel):
    """è®¾å¤‡ä¿¡æ¯"""
    device_id: str              # è®¾å¤‡åºåˆ—å· (å¦‚ emulator-5554, 192.168.1.100:5555)
    state: DeviceState
    model: str | None = None    # è®¾å¤‡å‹å· (å¦‚ Pixel 7)
    android_version: str | None = None
    screen_resolution: tuple[int, int] | None = None
    current_task_id: str | None = None  # å½“å‰æ‰§è¡Œçš„ä»»åŠ¡ ID

class DeviceManager:
    """å¤šè®¾å¤‡ç®¡ç†å™¨"""
    
    def __init__(self, adb_host: str = "127.0.0.1", adb_port: int = 5037):
        self.adb_host = adb_host
        self.adb_port = adb_port
        self._devices: dict[str, DeviceInfo] = {}
        self._lock = asyncio.Lock()
    
    async def scan_devices(self) -> list[DeviceInfo]:
        """æ‰«ææ‰€æœ‰è¿æ¥çš„è®¾å¤‡"""
        # æ‰§è¡Œ adb devices -l è·å–è®¾å¤‡åˆ—è¡¨
        ...
    
    async def get_device(self, device_id: str) -> DeviceInfo | None:
        """è·å–æŒ‡å®šè®¾å¤‡"""
        return self._devices.get(device_id)
    
    async def get_available_devices(self) -> list[DeviceInfo]:
        """è·å–æ‰€æœ‰å¯ç”¨ï¼ˆåœ¨çº¿ä¸”ç©ºé—²ï¼‰çš„è®¾å¤‡"""
        return [d for d in self._devices.values() if d.state == DeviceState.ONLINE]
    
    async def acquire_device(self, device_id: str, task_id: str) -> bool:
        """è·å–è®¾å¤‡ä½¿ç”¨æƒï¼ˆæ ‡è®°ä¸º BUSYï¼‰"""
        async with self._lock:
            device = self._devices.get(device_id)
            if device and device.state == DeviceState.ONLINE:
                device.state = DeviceState.BUSY
                device.current_task_id = task_id
                return True
            return False
    
    async def release_device(self, device_id: str) -> None:
        """é‡Šæ”¾è®¾å¤‡ï¼ˆæ ‡è®°ä¸º ONLINEï¼‰"""
        async with self._lock:
            device = self._devices.get(device_id)
            if device:
                device.state = DeviceState.ONLINE
                device.current_task_id = None

class ADBDevice:
    """å•ä¸ªè®¾å¤‡æ§åˆ¶å™¨"""
    
    def __init__(self, device_id: str, adb_host: str = "127.0.0.1", adb_port: int = 5037):
        self.device_id = device_id
        self.adb_host = adb_host
        self.adb_port = adb_port
    
    async def screenshot(self) -> bytes:
        """æˆªå–å±å¹•"""
        ...
    
    async def tap(self, x: int, y: int) -> bool:
        """ç‚¹å‡»åæ ‡"""
        ...
    
    async def swipe(self, x1: int, y1: int, x2: int, y2: int, duration: int = 300) -> bool:
        """æ»‘åŠ¨"""
        ...
    
    async def input_text(self, text: str) -> bool:
        """è¾“å…¥æ–‡æœ¬"""
        ...
    
    async def launch_app(self, package: str) -> bool:
        """å¯åŠ¨åº”ç”¨"""
        ...
    
    async def get_screen_size(self) -> tuple[int, int]:
        """è·å–å±å¹•åˆ†è¾¨ç‡"""
        ...
```

### ä»»åŠ¡è°ƒåº¦å™¨

```python
# agent/scheduler.py
from pydantic import BaseModel
from enum import Enum
from datetime import datetime
import asyncio
import uuid

class TaskState(str, Enum):
    PENDING = "pending"     # ç­‰å¾…æ‰§è¡Œ
    RUNNING = "running"     # æ­£åœ¨æ‰§è¡Œ
    COMPLETED = "completed" # å·²å®Œæˆ
    FAILED = "failed"       # æ‰§è¡Œå¤±è´¥
    CANCELLED = "cancelled" # å·²å–æ¶ˆ

class Task(BaseModel):
    """ä»»åŠ¡å®šä¹‰"""
    task_id: str
    description: str           # ä»»åŠ¡æè¿°ï¼ˆç”¨æˆ·è¾“å…¥çš„è‡ªç„¶è¯­è¨€æŒ‡ä»¤ï¼‰
    profile_name: str          # ä½¿ç”¨çš„æ¨¡å‹ Profile
    device_id: str | None = None  # æŒ‡å®šè®¾å¤‡ï¼ˆNone è¡¨ç¤ºè‡ªåŠ¨åˆ†é…ï¼‰
    state: TaskState = TaskState.PENDING
    created_at: datetime
    started_at: datetime | None = None
    completed_at: datetime | None = None
    result: str | None = None
    error: str | None = None
    step_count: int = 0
    total_cost: float = 0.0

class TaskScheduler:
    """ä»»åŠ¡è°ƒåº¦å™¨"""
    
    def __init__(
        self,
        device_manager: DeviceManager,
        profile_manager: "ProfileManager",
        billing_manager: "BillingManager",
        max_concurrent_tasks: int = 5,
    ):
        self.device_manager = device_manager
        self.profile_manager = profile_manager
        self.billing_manager = billing_manager
        self.max_concurrent_tasks = max_concurrent_tasks
        
        self._pending_queue: asyncio.Queue[Task] = asyncio.Queue()
        self._running_tasks: dict[str, Task] = {}
        self._completed_tasks: list[Task] = []
    
    async def submit_task(
        self,
        description: str,
        profile_name: str | None = None,
        device_id: str | None = None,
    ) -> Task:
        """æäº¤æ–°ä»»åŠ¡"""
        task = Task(
            task_id=str(uuid.uuid4()),
            description=description,
            profile_name=profile_name or self.profile_manager.default_profile.name,
            device_id=device_id,
            created_at=datetime.now(),
        )
        await self._pending_queue.put(task)
        return task
    
    async def run(self) -> None:
        """å¯åŠ¨è°ƒåº¦å¾ªç¯"""
        while True:
            # æ£€æŸ¥æ˜¯å¦æœ‰å¯ç”¨è®¾å¤‡å’Œå¾…æ‰§è¡Œä»»åŠ¡
            if len(self._running_tasks) < self.max_concurrent_tasks:
                try:
                    task = self._pending_queue.get_nowait()
                    asyncio.create_task(self._execute_task(task))
                except asyncio.QueueEmpty:
                    pass
            await asyncio.sleep(0.1)
    
    async def _execute_task(self, task: Task) -> None:
        """æ‰§è¡Œå•ä¸ªä»»åŠ¡"""
        # 1. è·å–å¯ç”¨è®¾å¤‡
        device_id = task.device_id
        if not device_id:
            devices = await self.device_manager.get_available_devices()
            if not devices:
                # æ²¡æœ‰å¯ç”¨è®¾å¤‡ï¼Œæ”¾å›é˜Ÿåˆ—
                await self._pending_queue.put(task)
                return
            device_id = devices[0].device_id
        
        # 2. è·å–è®¾å¤‡ä½¿ç”¨æƒ
        if not await self.device_manager.acquire_device(device_id, task.task_id):
            await self._pending_queue.put(task)
            return
        
        try:
            task.state = TaskState.RUNNING
            task.started_at = datetime.now()
            self._running_tasks[task.task_id] = task
            
            # 3. åˆ›å»º Agent å¹¶æ‰§è¡Œ
            profile = self.profile_manager.get_profile(task.profile_name)
            device = ADBDevice(device_id)
            agent = PhoneAgent(...)  # åˆ›å»º Agent
            
            result = await agent.run_async(task.description)
            
            task.result = result
            task.state = TaskState.COMPLETED
            
        except Exception as e:
            task.error = str(e)
            task.state = TaskState.FAILED
        
        finally:
            task.completed_at = datetime.now()
            await self.device_manager.release_device(device_id)
            del self._running_tasks[task.task_id]
            self._completed_tasks.append(task)
    
    def get_task(self, task_id: str) -> Task | None:
        """è·å–ä»»åŠ¡çŠ¶æ€"""
        if task_id in self._running_tasks:
            return self._running_tasks[task_id]
        for task in self._completed_tasks:
            if task.task_id == task_id:
                return task
        return None
```

### TUI å¤šè®¾å¤‡ç•Œé¢ç¤ºä¾‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ“± Phone Agent - Multi-Device Dashboard                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  ğŸ“± è®¾å¤‡åˆ—è¡¨                          ğŸ“‹ ä»»åŠ¡é˜Ÿåˆ—                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚ â— Pixel 7 Pro (å·²è¿æ¥)      â”‚     â”‚ ğŸ”„ æ‰“å¼€å¾®ä¿¡å‘æ¶ˆæ¯ç»™å¼ ä¸‰        â”‚â”‚
â”‚  â”‚   çŠ¶æ€: æ‰§è¡Œä¸­              â”‚     â”‚    è®¾å¤‡: Pixel 7 Pro           â”‚â”‚
â”‚  â”‚   ä»»åŠ¡: æ‰“å¼€å¾®ä¿¡å‘æ¶ˆæ¯...    â”‚     â”‚    çŠ¶æ€: æ‰§è¡Œä¸­ (æ­¥éª¤ 3/50)    â”‚â”‚
â”‚  â”‚   Profile: deepseek         â”‚     â”‚    Profile: deepseek           â”‚â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤â”‚
â”‚  â”‚ â— Samsung S24 (å·²è¿æ¥)      â”‚     â”‚ â³ æ‰“å¼€æ·˜å®æœç´¢è“ç‰™è€³æœº        â”‚â”‚
â”‚  â”‚   çŠ¶æ€: ç©ºé—²                â”‚     â”‚    è®¾å¤‡: å¾…åˆ†é…                â”‚â”‚
â”‚  â”‚                             â”‚     â”‚    çŠ¶æ€: ç­‰å¾…ä¸­                â”‚â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤â”‚
â”‚  â”‚ â— emulator-5554 (æ¨¡æ‹Ÿå™¨)    â”‚     â”‚ âœ… æŸ¥çœ‹ä»Šå¤©çš„å¤©æ°”              â”‚â”‚
â”‚  â”‚   çŠ¶æ€: ç©ºé—²                â”‚     â”‚    è®¾å¤‡: emulator-5554         â”‚â”‚
â”‚  â”‚                             â”‚     â”‚    çŠ¶æ€: å·²å®Œæˆ (5 æ­¥)         â”‚â”‚
â”‚  â”‚                             â”‚     â”‚    æˆæœ¬: $0.0023               â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                                                                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
â”‚                                                                         â”‚
â”‚  ğŸ“ è¾“å…¥æ–°ä»»åŠ¡: [æ‰“å¼€æŠ–éŸ³æœç´¢ç¾é£Ÿè§†é¢‘_______________] [æäº¤] [é€‰æ‹©è®¾å¤‡â–¼]â”‚
â”‚                                                                         â”‚
â”‚  ğŸ“Š ç»Ÿè®¡: å·²å®Œæˆ 12 ä¸ªä»»åŠ¡ | æ€»æˆæœ¬ $0.0847 | å¹³å‡è€—æ—¶ 45s              â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## App ä¸“å± Prompt ç³»ç»Ÿ

### ç›®å½•ç»“æ„

```
prompts/
â”œâ”€â”€ system/
â”‚   â”œâ”€â”€ default_zh.md       # é»˜è®¤ä¸­æ–‡ç³»ç»Ÿ Prompt
â”‚   â””â”€â”€ default_en.md       # é»˜è®¤è‹±æ–‡ç³»ç»Ÿ Prompt
â”œâ”€â”€ apps/
â”‚   â”œâ”€â”€ wechat.yaml         # å¾®ä¿¡ä¸“å± Prompt
â”‚   â”œâ”€â”€ taobao.yaml         # æ·˜å®ä¸“å± Prompt
â”‚   â”œâ”€â”€ douyin.yaml         # æŠ–éŸ³ä¸“å± Prompt
â”‚   â””â”€â”€ jx3/                # å¤æ‚ App ä½¿ç”¨ç›®å½•
â”‚       â”œâ”€â”€ main.yaml
â”‚       â””â”€â”€ dungeons.yaml
â””â”€â”€ custom/                 # ç”¨æˆ·è‡ªå®šä¹‰ Prompt
    â””â”€â”€ my_app.yaml
```

### YAML Prompt æ ¼å¼

```yaml
# prompts/apps/wechat.yaml
name: å¾®ä¿¡
package: com.tencent.mm
aliases:
  - WeChat
  - å¾®ä¿¡

system_prompt: |
  ## å¾®ä¿¡æ“ä½œä¸“å±æŒ‡å—
  
  ### ç•Œé¢ç»“æ„
  - åº•éƒ¨æœ‰4ä¸ªä¸»Tabï¼šå¾®ä¿¡ã€é€šè®¯å½•ã€å‘ç°ã€æˆ‘
  - èŠå¤©åˆ—è¡¨åœ¨"å¾®ä¿¡"Tabä¸‹
  - æœç´¢æ¡†åœ¨é¡¶éƒ¨
  
  ### å¸¸ç”¨æ“ä½œ
  1. å‘é€æ¶ˆæ¯ï¼šè¿›å…¥èŠå¤© â†’ è¾“å…¥æ¡†è¾“å…¥ â†’ ç‚¹å‡»å‘é€
  2. æœç´¢è”ç³»äººï¼šç‚¹å‡»æœç´¢æ¡† â†’ è¾“å…¥åç§° â†’ é€‰æ‹©ç»“æœ

scenarios:
  send_message:
    trigger: "å‘é€æ¶ˆæ¯|å‘æ¶ˆæ¯|è¯´"
    prompt: |
      å‘é€æ¶ˆæ¯æ“ä½œæ­¥éª¤ï¼š
      1. ç¡®ä¿åœ¨èŠå¤©ç•Œé¢
      2. ç‚¹å‡»è¾“å…¥æ¡†èšç„¦
      3. è¾“å…¥æ–‡æœ¬
      4. ç‚¹å‡»"å‘é€"æŒ‰é’®
```

### Prompt ç®¡ç†å™¨

```python
# prompts/manager.py
import yaml
from pathlib import Path
import re

class PromptManager:
    """Prompt ç®¡ç†å™¨"""
    
    def __init__(self, prompts_dir: str = "prompts"):
        self.prompts_dir = Path(prompts_dir)
        self._system_prompts: dict[str, str] = {}
        self._app_prompts: dict[str, dict] = {}
        self._loaded = False
    
    def load(self) -> None:
        """åŠ è½½æ‰€æœ‰ Prompt"""
        # åŠ è½½ç³»ç»Ÿ Prompt
        for lang_file in (self.prompts_dir / "system").glob("*.md"):
            lang = lang_file.stem.replace("default_", "")
            self._system_prompts[lang] = lang_file.read_text(encoding="utf-8")
        
        # åŠ è½½ App ä¸“å± Prompt
        for app_file in (self.prompts_dir / "apps").glob("*.yaml"):
            config = yaml.safe_load(app_file.read_text(encoding="utf-8"))
            app_name = config.get("name", app_file.stem)
            self._app_prompts[app_name] = config
            for alias in config.get("aliases", []):
                self._app_prompts[alias] = config
        
        self._loaded = True
    
    def get_system_prompt(self, lang: str = "zh") -> str:
        if not self._loaded:
            self.load()
        return self._system_prompts.get(lang, self._system_prompts.get("zh", ""))
    
    def get_app_prompt(self, app_name: str | None) -> str:
        if not self._loaded:
            self.load()
        if app_name is None:
            return ""
        config = self._app_prompts.get(app_name)
        return config.get("system_prompt", "") if config else ""
    
    def has_app_prompt(self, app_name: str | None) -> bool:
        if not self._loaded:
            self.load()
        return app_name in self._app_prompts if app_name else False
```

---

## é¡¹ç›®ç»“æ„

```
phone-agent/
â”œâ”€â”€ README.md
â”œâ”€â”€ pyproject.toml
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ .env.example                 # ç¯å¢ƒå˜é‡ç¤ºä¾‹ â­
â”‚
â”œâ”€â”€ phone_agent/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ agent/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ core.py              # PhoneAgent æ ¸å¿ƒ
â”‚   â”‚   â”œâ”€â”€ actions.py           # åŠ¨ä½œå¤„ç†å™¨
â”‚   â”‚   â””â”€â”€ scheduler.py         # ä»»åŠ¡è°ƒåº¦å™¨ â­ æ–°å¢
â”‚   â”‚
â”‚   â”œâ”€â”€ providers/
â”‚   â”‚   â”œâ”€â”€ __init__.py          # Provider å·¥å‚
â”‚   â”‚   â”œâ”€â”€ base.py              # æŠ½è±¡åŸºç±»
â”‚   â”‚   â”œâ”€â”€ openai_compatible.py # OpenAI/vLLM/DeepSeek/OpenRouter
â”‚   â”‚   â”œâ”€â”€ gemini.py            # Google Gemini
â”‚   â”‚   â””â”€â”€ anthropic.py         # Anthropic Claude
â”‚   â”‚
â”‚   â”œâ”€â”€ billing/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ models.py            # è®¡è´¹æ•°æ®æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ manager.py           # è®¡è´¹ç®¡ç†å™¨
â”‚   â”‚   â””â”€â”€ loader.py            # ä»·æ ¼é…ç½®åŠ è½½å™¨
â”‚   â”‚
â”‚   â”œâ”€â”€ prompts/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ manager.py           # Prompt ç®¡ç†å™¨
â”‚   â”‚   â””â”€â”€ parser.py            # å“åº”è§£æå™¨
â”‚   â”‚
â”‚   â”œâ”€â”€ adb/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ device_manager.py    # å¤šè®¾å¤‡ç®¡ç†å™¨ â­ æ–°å¢
â”‚   â”‚   â”œâ”€â”€ device.py            # å•è®¾å¤‡æ§åˆ¶å™¨
â”‚   â”‚   â”œâ”€â”€ input.py             # æ–‡æœ¬è¾“å…¥
â”‚   â”‚   â””â”€â”€ screenshot.py        # å±å¹•æˆªå›¾
â”‚   â”‚
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ settings.py          # å…¨å±€é…ç½®
â”‚   â”‚   â””â”€â”€ profile.py           # Profile ç®¡ç†å™¨ â­ æ–°å¢
â”‚   â”‚
â”‚   â””â”€â”€ tui/                      # TUI ç•Œé¢ â­ æ–°å¢
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ app.py               # Textual åº”ç”¨å…¥å£
â”‚       â”œâ”€â”€ screens/
â”‚       â”‚   â”œâ”€â”€ main.py          # ä¸»ç•Œé¢
â”‚       â”‚   â”œâ”€â”€ devices.py       # è®¾å¤‡ç®¡ç†ç•Œé¢
â”‚       â”‚   â””â”€â”€ tasks.py         # ä»»åŠ¡ç®¡ç†ç•Œé¢
â”‚       â””â”€â”€ widgets/
â”‚           â”œâ”€â”€ device_list.py   # è®¾å¤‡åˆ—è¡¨ç»„ä»¶
â”‚           â””â”€â”€ task_queue.py    # ä»»åŠ¡é˜Ÿåˆ—ç»„ä»¶
â”‚
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ profiles.yaml            # Profile é…ç½® â­ æ–°å¢
â”‚   â””â”€â”€ pricing.yaml             # æ¨¡å‹ä»·æ ¼é…ç½®
â”‚
â”œâ”€â”€ prompts/                     # Prompt èµ„æºç›®å½•
â”‚   â”œâ”€â”€ system/
â”‚   â”œâ”€â”€ apps/
â”‚   â””â”€â”€ custom/
â”‚
â”œâ”€â”€ main.py                      # TUI åº”ç”¨å…¥å£ â­ æ–°å¢
â”œâ”€â”€ server.py                    # Web API æœåŠ¡
â”œâ”€â”€ cli.py                       # å‘½ä»¤è¡Œå·¥å…·
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ test_providers/
    â”œâ”€â”€ test_billing/
    â”œâ”€â”€ test_adb/                # ADB å¤šè®¾å¤‡æµ‹è¯• â­ æ–°å¢
    â”œâ”€â”€ test_prompts/
    â””â”€â”€ test_agent/
```


---

## é…ç½®ç³»ç»Ÿ

é‡‡ç”¨ **Profileï¼ˆé…ç½®æ¡£æ¡ˆï¼‰** æ¶æ„ï¼Œè§£è€¦ä¾›åº”å•†ã€åè®®ã€æ¨¡å‹ä¸‰å±‚å…³ç³»ï¼š

| å±‚çº§ | è¯´æ˜ | ç¤ºä¾‹ |
|------|------|------|
| **Vendorï¼ˆä¾›åº”å•†ï¼‰** | API æœåŠ¡æä¾›æ–¹ | OpenAIã€DeepSeekã€OpenRouterã€ç«å±±æ–¹èˆŸ |
| **Protocolï¼ˆåè®®ï¼‰** | API è°ƒç”¨è§„èŒƒ | `openai`ã€`anthropic`ã€`google` |
| **Modelï¼ˆæ¨¡å‹ï¼‰** | å…·ä½“æ¨¡å‹æ ‡è¯† | `gpt-4o`ã€`deepseek-chat`ã€`gemini-2.0-flash` |

### æ–‡ä»¶åˆ†å·¥

| æ–‡ä»¶ | å†…å®¹ |
|------|------|
| `.env` | API Keys + å…¨å±€é…ç½® + é»˜è®¤ Profile |
| `config/profiles.yaml` | Profile å®šä¹‰ï¼ˆå¼•ç”¨ .env ä¸­çš„ API Keyï¼‰ |
| `config/pricing.yaml` | æ¨¡å‹ä»·æ ¼é…ç½® |

### ç¯å¢ƒå˜é‡é…ç½® (.env)

```bash
# =====================================================
# Phone-Agent ç¯å¢ƒå˜é‡é…ç½®
# =====================================================

# é»˜è®¤æ¿€æ´»çš„ Profileï¼ˆå¯¹åº” profiles.yaml ä¸­çš„åç§°ï¼‰
PHONE_AGENT_DEFAULT_PROFILE=deepseek

# API Keysï¼ˆåœ¨ profiles.yaml ä¸­é€šè¿‡ ${VAR_NAME} å¼•ç”¨ï¼‰
OPENAI_API_KEY=sk-xxx
DEEPSEEK_API_KEY=sk-xxx
OPENROUTER_API_KEY=sk-or-xxx
ANTHROPIC_API_KEY=sk-ant-xxx
GOOGLE_API_KEY=xxx
VOLCANO_API_KEY=xxx

# å…¨å±€é…ç½®
PHONE_AGENT_PROFILES_CONFIG_PATH=config/profiles.yaml
PHONE_AGENT_BILLING_ENABLED=true
PHONE_AGENT_BILLING_CONFIG_PATH=config/pricing.yaml
PHONE_AGENT_LOG_LEVEL=INFO
```

### Profile é…ç½® (profiles.yaml)

```yaml
# config/profiles.yaml
default_profile: deepseek

profiles:
  # ===== OpenAI å®˜æ–¹ =====
  openai_gpt4o:
    vendor: OpenAI
    protocol: openai
    base_url: https://api.openai.com/v1
    api_key: ${OPENAI_API_KEY}
    model: gpt-4o
    description: "OpenAI GPT-4o - é«˜æ€§èƒ½å¤šæ¨¡æ€"
    
  openai_mini:
    vendor: OpenAI
    protocol: openai
    base_url: https://api.openai.com/v1
    api_key: ${OPENAI_API_KEY}
    model: gpt-4o-mini
    description: "OpenAI GPT-4o Mini - æ€§ä»·æ¯”ä¹‹é€‰"
  
  # ===== DeepSeek =====
  deepseek:
    vendor: DeepSeek
    protocol: openai
    base_url: https://api.deepseek.com
    api_key: ${DEEPSEEK_API_KEY}
    model: deepseek-chat
    description: "DeepSeek Chat - å›½äº§é«˜æ€§ä»·æ¯”"
    
  deepseek_vl2:
    vendor: DeepSeek
    protocol: openai
    base_url: https://api.deepseek.com
    api_key: ${DEEPSEEK_API_KEY}
    model: deepseek-vl2
    description: "DeepSeek VL2 - è§†è§‰ç†è§£æ¨¡å‹"
  
  # ===== OpenRouter èšåˆ =====
  openrouter_claude:
    vendor: OpenRouter
    protocol: openai
    base_url: https://openrouter.ai/api/v1
    api_key: ${OPENROUTER_API_KEY}
    model: anthropic/claude-sonnet-4-20250514
    description: "Claude Sonnet 4 via OpenRouter"
    extra_headers:
      HTTP-Referer: https://github.com/your-repo
      X-Title: Phone-Agent
  
  # ===== Anthropic å®˜æ–¹ =====
  anthropic_claude:
    vendor: Anthropic
    protocol: anthropic
    base_url: https://api.anthropic.com
    api_key: ${ANTHROPIC_API_KEY}
    model: claude-sonnet-4-20250514
    description: "Claude Sonnet 4 - ç›´è¿å®˜æ–¹"
  
  # ===== Google Gemini =====
  gemini_flash:
    vendor: Google
    protocol: google
    api_key: ${GOOGLE_API_KEY}
    model: gemini-2.0-flash
    description: "Gemini 2.0 Flash - å¿«é€Ÿå“åº”"
  
  # ===== ç«å±±æ–¹èˆŸ =====
  volcano_doubao:
    vendor: ç«å±±æ–¹èˆŸ
    protocol: openai
    base_url: https://ark.cn-beijing.volces.com/api/v3
    api_key: ${VOLCANO_API_KEY}
    model: ep-xxxxx
    description: "è±†åŒ…è§†è§‰æ¨¡å‹"
  
  # ===== æœ¬åœ°éƒ¨ç½² =====
  local_vllm:
    vendor: Local
    protocol: openai
    base_url: http://localhost:8000/v1
    api_key: not-needed
    model: autoglm-phone-9b
    description: "æœ¬åœ° vLLM éƒ¨ç½²"
```

### å®Œæ•´ä½¿ç”¨ç¤ºä¾‹

```python
from phone_agent import PhoneAgent, AgentConfig
from phone_agent.config import ProfileManager, load_pricing_config
from phone_agent.providers import create_vlm_client_from_profile
from phone_agent.prompts import PromptManager
from phone_agent.adb import DeviceManager
from phone_agent.agent.actions import ActionHandler

# 1. åŠ è½½é…ç½®
profile_manager = ProfileManager()
profile_manager.load_from_yaml("config/profiles.yaml")
billing_manager = load_pricing_config("config/pricing.yaml")
prompt_manager = PromptManager("prompts")

# 2. è·å–å½“å‰ Profile å¹¶åˆ›å»º VLM å®¢æˆ·ç«¯
profile = profile_manager.get_profile("deepseek")
vlm_client = create_vlm_client_from_profile(profile)

# 3. è·å–å¯ç”¨è®¾å¤‡å¹¶é€‰æ‹©
device_manager = DeviceManager()
devices = device_manager.list_devices()
device = devices[0]  # é€‰æ‹©ç¬¬ä¸€ä¸ªè®¾å¤‡

# 4. åˆ›å»º Agent
agent = PhoneAgent(
    config=AgentConfig(
        profile=profile,
        enable_billing=True,
        max_steps=50,
    ),
    vlm_client=vlm_client,
    prompt_manager=prompt_manager,
    action_handler=ActionHandler(device),
    billing_manager=billing_manager,
)

# 5. æ‰§è¡Œä»»åŠ¡
result = agent.run("æ‰“å¼€æ·˜å®æœç´¢è“ç‰™è€³æœº")
print(result)

# 6. æŸ¥çœ‹è®¡è´¹æŠ¥å‘Š
print(billing_manager.export_report())
```

---

## æ‰©å±•æŒ‡å—

### æ·»åŠ æ–°çš„ VLM Provider

1. åœ¨ `providers/` åˆ›å»ºæ–°æ–‡ä»¶
2. ç»§æ‰¿ `BaseVLMClient` å¹¶å®ç°æ‰€æœ‰æ–¹æ³•
3. åœ¨ `providers/__init__.py` æ³¨å†Œ
4. åœ¨ `config/pricing.yaml` æ·»åŠ ä»·æ ¼é…ç½®

### æ·»åŠ æ–°çš„ App Prompt

åœ¨ `prompts/apps/` åˆ›å»º YAML æ–‡ä»¶ï¼š

```yaml
name: æˆ‘çš„åº”ç”¨
package: com.example.myapp
system_prompt: |
  è¿™æ˜¯æˆ‘çš„åº”ç”¨çš„ä¸“å±æç¤ºè¯...
```

### æ·»åŠ æ–°çš„æ¨¡å‹ä»·æ ¼

åœ¨ `config/pricing.yaml` æ·»åŠ ï¼š

```yaml
- provider: my_provider
  model: my-model
  pricing_type: fixed
  input_price_per_million: 1.00
  output_price_per_million: 5.00
```

---

## ä¾èµ–æ¸…å•

```toml
# pyproject.toml
[project]
name = "phone-agent"
version = "0.1.0"
requires-python = ">=3.10"

dependencies = [
    "openai>=1.0.0",
    "google-generativeai",
    "anthropic",
    "pydantic>=2.0",
    "pyyaml",
    "aiohttp",
    "python-dotenv",
]

[project.optional-dependencies]
dev = ["pytest", "pytest-asyncio", "black", "ruff"]
server = ["fastapi", "uvicorn", "websockets"]
```

---

> **æ–‡æ¡£ç‰ˆæœ¬**: v2.0.0  
> **æ›´æ–°æ—¥æœŸ**: 2025-12-23  
> **æ–°å¢åŠŸèƒ½**: Profile é…ç½®æ¶æ„ã€å¤šè®¾å¤‡ç®¡ç†ã€ä»»åŠ¡è°ƒåº¦å™¨ã€TUI ç•Œé¢è®¾è®¡  
